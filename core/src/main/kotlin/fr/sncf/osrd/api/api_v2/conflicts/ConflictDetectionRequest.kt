package fr.sncf.osrd.api.api_v2.conflicts

import com.squareup.moshi.Json
import com.squareup.moshi.JsonAdapter
import com.squareup.moshi.Moshi
import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
import fr.sncf.osrd.api.api_v2.RoutingRequirement
import fr.sncf.osrd.api.api_v2.SpacingRequirement
import fr.sncf.osrd.api.api_v2.WorkSchedule
import fr.sncf.osrd.utils.json.UnitAdapterFactory
import java.time.ZonedDateTime

class ConflictDetectionRequest(
    /** Infra ID. */
    var infra: String,
    /** Expected infra version, used for cache invalidation. */
    @Json(name = "expected_version") var expectedVersion: String,
    /**
     * Map of train id -> train requirements. The train requirements should be generated by the
     * simulation endpoint.
     */
    @Json(name = "trains_requirements") val trainsRequirements: Map<Long, TrainRequirementsRequest>,
    /** Work schedules, if any. */
    @Json(name = "work_schedules") val workSchedules: WorkSchedulesRequest? = null,
)

/** Describes the requirements needed for a given train to run without any delay. */
class TrainRequirementsRequest(
    /**
     * Start time for the given train. Acts as a reference point for all time values in the spacing
     * and routing requirements for this train (values expressed as time delta).
     */
    @Json(name = "start_time") val startTime: ZonedDateTime,
    /**
     * Spacing requirements for the given train (i.e. which zones need to be free in which time
     * ranges).
     */
    @Json(name = "spacing_requirements") val spacingRequirements: Collection<SpacingRequirement>,
    /**
     * Routing requirements for the given train (i.e. which routes need to be usable in which time
     * ranges).
     */
    @Json(name = "routing_requirements") val routingRequirements: Collection<RoutingRequirement>,
)

/** Describes the set of work schedules in the given timetable. */
class WorkSchedulesRequest(
    /**
     * Reference time for other time values in the work schedule requirements (expressed as time
     * deltas).
     */
    @Json(name = "start_time") val startTime: ZonedDateTime,
    /** Map of work schedule id -> work schedule data. */
    @Json(name = "work_schedule_requirements") val workScheduleRequirements: Map<Long, WorkSchedule>
)

val conflictRequestAdapter: JsonAdapter<ConflictDetectionRequest> =
    Moshi.Builder()
        .addLast(UnitAdapterFactory())
        .addLast(KotlinJsonAdapterFactory())
        .build()
        .adapter(ConflictDetectionRequest::class.java)
