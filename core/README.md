# OSRD's Simulation backend

## Design Goals

- **Microscopic**: The movement of trains should be accurately simulated, as well as their interactions with interlocking / signaling
- **Readable**: The code must be kept to very high quality standards, so everyone can contribute
- **Modular**: Users should be able to easily integrate their own hardware and behaviors
- **Observable**: What happens in the simulation must be easy to monitor
- **Fast**: Simulating a full day of operation for 500+ trains shouldn't take hours

Many of these goals currently aren't _yet_ fulfilled: the simulation is pretty slow, and the feature set is very limited.

## Simulation roadmap

- [x] Reasonably accurate simulation of train movement
- [x] Import of railML3 infrastructure
- [x] Static speed restrictions
- [x] Full history of internal simulation events
- [x] Basic interlocking / signaling support
- [x] Make the train react to signals
- [x] pathfinding in the route graph
- [x] API server mode
- [ ] ERTMS support
- [ ] Parallel integration of train movement
- [x] Variable step integration
- [ ] Driver behavior model
- [ ] ~~Rewrite everything in Rust~~

## Getting Started

You'll need **Java 17**


### Server usage (preferred)

```sh
# on Linux / MacOS
./gradlew shadowJar

# on Windows
gradlew.bat shadowJar

# Run as a RabbitMQ single worker for all infra
ALL_INFRA=true java -jar build/libs/osrd-all.jar worker --editoast-url http://localhost:8090/

# Check that an infra can be loaded
java -jar build/libs/osrd-all.jar load-infra --path RAILJSON_INFRA

# Run as web-service (deprecated inside OSRD's stack)
java -jar build/libs/osrd-all.jar api --editoast-url http://localhost:8090/ --port 8080
```

### CLI usage (alternative)

```sh
# on Linux / MacOS
./gradlew shadowJar

# on Windows
gradlew.bat shadowJar

# Run a simulation. You can use the files generated by the previous command
# in ./build/generated_examples/small_infra for an example of the formats used.
java -jar build/libs/osrd-all.jar standalone-simulation --infra_path example/infra.json \
      --sim_path example/simulation.json --res_path example/results.json
```

### Tests and tooling

To launch all the checks on core (tests and code quality), run:

```sh
./gradlew check
```

To launch tests only, run:

```sh
./gradlew test
```

To auto-format all source code, run:

```sh
./gradlew spotlessApply
```

### Local run and debug

It is recommended to pass additional Java options to enable the process of big infra:

```sh
-ea -Xmx12g -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=dump.hprof
```

Using a specific script (just through `docker compose` CLI and a set of docker-compose files)
allows to run a single core worker for all infra on localhost network:

```sh
./scripts/single-worker-compose.sh up -d

# or exclude 'core' service straight away:
./scripts/single-worker-compose.sh up -d --scale core=0
```

Then, it is easy to replace the desired component for debug purpose. \
For core:

```sh
./scripts/single-worker-compose.sh down core # if 'core' is running
./gradlew shadowJar && ALL_INFRA=true java -jar -ea -Xmx12g -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=dump.hprof build/libs/osrd-all.jar worker --editoast-url http://localhost:8090/
```

Clean or restart the whole stack can be necessary sometimes and is also available
through docker compose CLI (the following wipes the database too):
```sh
./scripts/single-worker-compose.sh down -v
```
