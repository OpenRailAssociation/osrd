use diesel::dsl::sql;
use diesel::expression::expression_types::NotSelectable;
use diesel::expression::{AsExpression, TypedExpressionType};
use diesel::pg::Pg;
use diesel::query_builder::{AstPass, Query, QueryFragment};
use diesel::sql_types::{BigInt, Bool, Nullable, SqlType};
use std::sync::Arc;

use crate::modelsv2::DbConnection;

use super::Model;

/// A dynamic container for a filter setting in a [SelectionSettings] context
///
/// This struct is not meant to be initialized direclty but rather through the
/// [ModelField](super::ModelField) objects generated by the `Model` derive macro expansion.
pub struct FilterSetting<M: Model>(pub(in crate::modelsv2) DieselFilter<M::Table>);
type DieselFilter<Table> = Box<dyn diesel::BoxableExpression<Table, Pg, SqlType = Bool>>;

impl<M: Model> FilterSetting<M> {
    /// Initializes a filter setting with a given filter expression
    ///
    /// This function is only used internally by the `Model` derive macro and it
    /// probably should stay that way. It exists to allow building a [FilterSetting]
    /// both from a `Bool` and `Nullable<Bool>` query by `COALESCE`ing the expression
    /// to `FALSE`. That way the `Model` derive macro doesn't have to infer the type
    /// of each field (as `column.eq(value)` is a `Nullable<Bool>` if `column` is a `Nullable<T>`).
    #[allow(unused)] // FIXME: rmove this attribute asap
    pub(in crate::modelsv2) fn new<T, Q>(filter: Q) -> Self
    where
        Q: AsExpression<T>,
        <Q as AsExpression<T>>::Expression: QueryFragment<Pg> + Send + 'static,
        T: SqlType + TypedExpressionType,
    {
        let expr = sql::<Bool>("COALESCE(").bind(filter).sql(", FALSE)");
        Self(Box::new(expr))
    }
}

/// A dynamic container for a sorting setting in a [SelectionSettings] context
///
/// This struct is not meant to be initialized direclty but rather through the
/// [ModelField](super::ModelField) objects generated by the `Model` derive macro expansion.
pub struct SortSetting<M: Model>(pub(in crate::modelsv2) DieselSort<M::Table>);
type DieselSort<Table> = Box<dyn diesel::BoxableExpression<Table, Pg, SqlType = NotSelectable>>;

/// A builder struct to accumulate settings that define a
/// selection of [Model] objects
///
/// Used by the [List] and [Count] traits to determine which rows
/// to consider.
pub struct SelectionSettings<M: Model> {
    pub(in crate::modelsv2) filters: Vec<Arc<dyn Fn() -> FilterSetting<M> + Send + Sync>>,
    pub(in crate::modelsv2) sorts: Vec<Arc<dyn Fn() -> SortSetting<M> + Send + Sync>>,
    pub(in crate::modelsv2) limit: Option<i64>,
    pub(in crate::modelsv2) offset: Option<i64>,
    pub(in crate::modelsv2) paginate_counting: bool,
}

impl<M: Model> Default for SelectionSettings<M> {
    fn default() -> Self {
        Self {
            filters: Vec::new(),
            sorts: Vec::new(),
            limit: None,
            offset: None,
            paginate_counting: false,
        }
    }
}

impl<M: Model> Clone for SelectionSettings<M> {
    fn clone(&self) -> Self {
        Self {
            filters: self.filters.clone(),
            sorts: self.sorts.clone(),
            limit: self.limit,
            offset: self.offset,
            paginate_counting: self.paginate_counting,
        }
    }
}

impl<M: Model + 'static> SelectionSettings<M> {
    /// Initializes a settings builder with no constraints
    #[allow(unused)] // FIXME: rmove this attribute asap
    pub fn new() -> Self {
        Self::default()
    }

    /// Add a row filter to the selection settings
    ///
    /// The filter is a function that returns a [FilterSetting] object.
    ///
    /// This function will be called multiple times if the same settings object
    /// is used for multiple queries (e.g. with [Count::count] or [List::list]).
    /// It means that the funciton must be able to produce a valid filter multiple times,
    /// so if `f` is a closure, its captured variables must be `Clone`d at each call.
    /// Keep in mind that the function may also be called concurrently if the settings
    /// object is shared between multiple concurrent tasks.
    ///
    /// We want [SelectionSettings] to implement `Clone` to allow it to be used multiple
    /// times in different queries. However, [FilterSetting] is cannot be cloned as it
    /// wraps `diesel::BoxableExpression` which is not `Clone`. To work around this, we
    /// instead clone an `Arc` of functions that are able to produce a new filter every
    /// time we need it.
    #[allow(unused)] // FIXME: rmove this attribute asap
    pub fn filter<F: Fn() -> FilterSetting<M> + Send + Sync + 'static>(mut self, f: F) -> Self {
        self.filters.push(Arc::new(f));
        self
    }

    /// Add a sorting criteria to the selection settings
    ///
    /// This parameter is ignored for [Count::count] queries.
    ///
    /// The sort is a function that returns a [SortSetting] object.
    ///
    /// This function will be called multiple times if the same settings object
    /// is used for multiple queries (e.g. with [Count::count] or [List::list]).
    /// It means that the funciton must be able to produce a valid sort multiple times,
    /// so if `f` is a closure, its captured variables must be `Clone`d at each call.
    /// Keep in mind that the function may also be called concurrently if the settings
    /// object is shared between multiple concurrent tasks.
    ///
    /// We want [SelectionSettings] to implement `Clone` to allow it to be used multiple
    /// times in different queries. However, [SortSetting] is cannot be cloned as it
    /// wraps `diesel::BoxableExpression` which is not `Clone`. To work around this, we
    /// instead clone an `Arc` of functions that are able to produce a new sort every
    /// time we need it.
    #[allow(unused)] // FIXME: rmove this attribute asap
    pub fn order_by<F: Fn() -> SortSetting<M> + Send + Sync + 'static>(mut self, f: F) -> Self {
        self.sorts.push(Arc::new(f));
        self
    }

    /// Limit the number of results
    #[allow(unused)] // FIXME: rmove this attribute asap
    pub fn limit(mut self, limit: u64) -> Self {
        self.limit = Some(limit.try_into().expect("limit is too large"));
        self
    }

    /// Offset the results by an amount
    #[allow(unused)] // FIXME: rmove this attribute asap
    pub fn offset(mut self, offset: u64) -> Self {
        self.offset = Some(offset.try_into().expect("offset is too large"));
        self
    }

    /// Signals to [Count::count] that the limit and the offset defined in this
    /// settings should not be ignored (default behavior) and be included in the
    /// query.
    ///
    /// Only useful if you are working with [Count::count].
    #[allow(unused)] // FIXME: rmove this attribute asap
    pub fn pagination_on_count(mut self, paginate: bool) -> Self {
        self.paginate_counting = paginate;
        self
    }
}

/// Describes how a [Model](super::Model) can be listed (and counted) in a database
/// given some settings and constraints provided by [SelectionSettings]
///
/// You can implement this type manually but it is recommended to use the `Model`
/// derive macro instead.
#[async_trait::async_trait]
pub trait List: Model {
    /// Lists and counts the objects that match the provided settings
    async fn list_and_count(
        conn: &'async_trait mut DbConnection,
        settings: SelectionSettings<Self>,
    ) -> crate::error::Result<(Vec<Self>, u64)>;

    /// Lists the objects that match the provided settings
    ///
    /// This function has a default implementation that relies on [Self::list_and_count],
    /// but it is recommended to override it with a more efficient implementation if possible
    /// as the counting operation can be expensive.
    async fn list(
        conn: &'async_trait mut DbConnection,
        settings: SelectionSettings<Self>,
    ) -> crate::error::Result<Vec<Self>> {
        let (list, _) = Self::list_and_count(conn, settings).await?;
        Ok(list)
    }
}

/// A composite query that returns the count of objects produced by `Q`
/// and the objects themselves (optionally with a limit and offset applied)
///
/// This struct is meant to be used for the implementation of the [List] trait,
/// which is usually provided by the `Model` derive macro expansion.
#[derive(diesel::QueryId)]
pub(in crate::modelsv2) struct ListAndCountQuery<Q> {
    pub(in crate::modelsv2) query: Q,
    pub(in crate::modelsv2) limit: Option<i64>,
    pub(in crate::modelsv2) offset: Option<i64>,
}

impl<Q: Query> Query for ListAndCountQuery<Q> {
    type SqlType = (BigInt, Nullable<Q::SqlType>);
}

impl<Q: QueryFragment<Pg>> QueryFragment<Pg> for ListAndCountQuery<Q> {
    fn walk_ast<'b>(&'b self, mut out: AstPass<'_, 'b, Pg>) -> diesel::result::QueryResult<()> {
        // Some explanations on the SQL query:
        // 1. __unbounded_query is the original query without the limit and offset.
        //    We use it to count the number of objects that match the settings in the whole table.
        // 2. __og_query is the original query with the limit and offset applied.
        // 3. __count_query is a 1-row, 1-column query that counts the number of objects in __unbounded_query.
        // 4. We aggregate the results of __count_query and __og_query to return the count and the data.
        //
        // We use a LEFT JOIN to ensure that the count is always returned, even if there are no objects.
        // For example, this can happen when the OFFSET overshoots the last row that matches the filters.
        // In this case, we still want the number of rows behind the OFFSET to be counted,
        // but we don't wan any row data (since we're beyond that OFFSET).
        out.push_sql("WITH __unbounded_query AS (");
        self.query.walk_ast(out.reborrow())?;
        out.push_sql("), __og_query AS (");
        self.query.walk_ast(out.reborrow())?;
        if let Some(ref limit) = self.limit {
            out.push_sql(" LIMIT ");
            out.push_bind_param::<BigInt, _>(limit)?;
        }
        if let Some(ref offset) = self.offset {
            out.push_sql(" OFFSET ");
            out.push_bind_param::<BigInt, _>(offset)?;
        }
        out.push_sql(
            "), __count_query AS (
                SELECT COUNT(*) FROM __unbounded_query
            )
            SELECT __count_query.*, __og_query.*
            FROM __count_query
              LEFT JOIN __og_query ON true",
        );
        Ok(())
    }
}

/// A simple proxy container meant to be used to aggregate the results of a `ListAndCountQuery` query
///
/// This struct is meant to be used for the implementation of the [List] trait,
/// which is usually provided by the `Model` derive macro expansion.
pub(in crate::modelsv2) struct ListAndCountIntermediateContainer<T> {
    pub(in crate::modelsv2) count: i64,
    pub(in crate::modelsv2) data: Vec<T>,
}

impl<T: Model> Extend<(i64, Option<T::Row>)> for ListAndCountIntermediateContainer<T> {
    fn extend<I: IntoIterator<Item = (i64, Option<T::Row>)>>(&mut self, iter: I) {
        for (count, data) in iter {
            self.count = count;
            if let Some(row) = data {
                self.data.push(T::from_row(row));
            }
        }
    }
}

impl<T> Default for ListAndCountIntermediateContainer<T> {
    fn default() -> Self {
        Self {
            count: 0,
            data: Vec::new(),
        }
    }
}

impl<T> ListAndCountIntermediateContainer<T> {
    pub(in crate::modelsv2) fn into_result(self) -> (Vec<T>, u64) {
        (self.data, self.count as u64)
    }
}
