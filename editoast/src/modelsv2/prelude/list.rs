use diesel::dsl::sql;
use diesel::expression::expression_types::NotSelectable;
use diesel::expression::{AsExpression, TypedExpressionType};
use diesel::pg::Pg;
use diesel::query_builder::QueryFragment;
use diesel::sql_types::{Bool, SqlType};
use std::sync::Arc;

use crate::modelsv2::DbConnection;

use super::Model;

/// A dynamic container for a filter setting in a [SelectionSettings] context
///
/// This struct is not meant to be initialized direclty but rather through the
/// [ModelField](super::ModelField) objects generated by the `Model` derive macro expansion.
pub struct FilterSetting<M: Model>(pub(in crate::modelsv2) DieselFilter<M::Table>);
type DieselFilter<Table> = Box<dyn diesel::BoxableExpression<Table, Pg, SqlType = Bool>>;

impl<M: Model> FilterSetting<M> {
    /// Initializes a filter setting with a given filter expression
    ///
    /// This function is only used internally by the `Model` derive macro and it
    /// probably should stay that way. It exists to allow building a [FilterSetting]
    /// both from a `Bool` and `Nullable<Bool>` query by `COALESCE`ing the expression
    /// to `FALSE`. That way the `Model` derive macro doesn't have to infer the type
    /// of each field (as `column.eq(value)` is a `Nullable<Bool>` if `column` is a `Nullable<T>`).
    #[allow(unused)] // FIXME: rmove this attribute asap
    pub(in crate::modelsv2) fn new<T, Q>(filter: Q) -> Self
    where
        Q: AsExpression<T>,
        <Q as AsExpression<T>>::Expression: QueryFragment<Pg> + Send + 'static,
        T: SqlType + TypedExpressionType,
    {
        let expr = sql::<Bool>("COALESCE(").bind(filter).sql(", FALSE)");
        Self(Box::new(expr))
    }
}

/// A dynamic container for a sorting setting in a [SelectionSettings] context
///
/// This struct is not meant to be initialized direclty but rather through the
/// [ModelField](super::ModelField) objects generated by the `Model` derive macro expansion.
pub struct SortSetting<M: Model>(pub(in crate::modelsv2) DieselSort<M::Table>);
type DieselSort<Table> = Box<dyn diesel::BoxableExpression<Table, Pg, SqlType = NotSelectable>>;

/// A builder struct to accumulate settings that define a
/// selection of [Model] objects
///
/// Used by the [List] and [Count] traits to determine which rows
/// to consider.
pub struct SelectionSettings<M: Model> {
    pub(in crate::modelsv2) filters: Vec<Arc<dyn Fn() -> FilterSetting<M> + Send + Sync>>,
    pub(in crate::modelsv2) sorts: Vec<Arc<dyn Fn() -> SortSetting<M> + Send + Sync>>,
    pub(in crate::modelsv2) limit: Option<i64>,
    pub(in crate::modelsv2) offset: Option<i64>,
    pub(in crate::modelsv2) paginate_counting: bool,
}

impl<M: Model> Default for SelectionSettings<M> {
    fn default() -> Self {
        Self {
            filters: Vec::new(),
            sorts: Vec::new(),
            limit: None,
            offset: None,
            paginate_counting: false,
        }
    }
}

impl<M: Model> Clone for SelectionSettings<M> {
    fn clone(&self) -> Self {
        Self {
            filters: self.filters.clone(),
            sorts: self.sorts.clone(),
            limit: self.limit,
            offset: self.offset,
            paginate_counting: self.paginate_counting,
        }
    }
}

impl<M: Model + 'static> SelectionSettings<M> {
    /// Initializes a settings builder with no constraints
    #[allow(unused)] // FIXME: rmove this attribute asap
    pub fn new() -> Self {
        Self::default()
    }

    /// Add a row filter to the selection settings
    ///
    /// The filter is a function that returns a [FilterSetting] object.
    ///
    /// This function will be called multiple times if the same settings object
    /// is used for multiple queries (e.g. with [Count::count] or [List::list]).
    /// It means that the funciton must be able to produce a valid filter multiple times,
    /// so if `f` is a closure, its captured variables must be `Clone`d at each call.
    /// Keep in mind that the function may also be called concurrently if the settings
    /// object is shared between multiple concurrent tasks.
    ///
    /// We want [SelectionSettings] to implement `Clone` to allow it to be used multiple
    /// times in different queries. However, [FilterSetting] is cannot be cloned as it
    /// wraps `diesel::BoxableExpression` which is not `Clone`. To work around this, we
    /// instead clone an `Arc` of functions that are able to produce a new filter every
    /// time we need it.
    #[allow(unused)] // FIXME: rmove this attribute asap
    pub fn filter<F: Fn() -> FilterSetting<M> + Send + Sync + 'static>(mut self, f: F) -> Self {
        self.filters.push(Arc::new(f));
        self
    }

    /// Add a sorting criteria to the selection settings
    ///
    /// This parameter is ignored for [Count::count] queries.
    ///
    /// The sort is a function that returns a [SortSetting] object.
    ///
    /// This function will be called multiple times if the same settings object
    /// is used for multiple queries (e.g. with [Count::count] or [List::list]).
    /// It means that the funciton must be able to produce a valid sort multiple times,
    /// so if `f` is a closure, its captured variables must be `Clone`d at each call.
    /// Keep in mind that the function may also be called concurrently if the settings
    /// object is shared between multiple concurrent tasks.
    ///
    /// We want [SelectionSettings] to implement `Clone` to allow it to be used multiple
    /// times in different queries. However, [SortSetting] is cannot be cloned as it
    /// wraps `diesel::BoxableExpression` which is not `Clone`. To work around this, we
    /// instead clone an `Arc` of functions that are able to produce a new sort every
    /// time we need it.
    #[allow(unused)] // FIXME: rmove this attribute asap
    pub fn order_by<F: Fn() -> SortSetting<M> + Send + Sync + 'static>(mut self, f: F) -> Self {
        self.sorts.push(Arc::new(f));
        self
    }

    /// Limit the number of results
    #[allow(unused)] // FIXME: rmove this attribute asap
    pub fn limit(mut self, limit: u64) -> Self {
        self.limit = Some(limit.try_into().expect("limit is too large"));
        self
    }

    /// Offset the results by an amount
    #[allow(unused)] // FIXME: rmove this attribute asap
    pub fn offset(mut self, offset: u64) -> Self {
        self.offset = Some(offset.try_into().expect("offset is too large"));
        self
    }

    /// Signals to [Count::count] that the limit and the offset defined in this
    /// settings should not be ignored (default behavior) and be included in the
    /// query.
    ///
    /// Only useful if you are working with [Count::count].
    #[allow(unused)] // FIXME: rmove this attribute asap
    pub fn pagination_on_count(mut self, paginate: bool) -> Self {
        self.paginate_counting = paginate;
        self
    }

    /// Returns a new [SelectionSettings] with pre-filled [Self::limit] and
    /// [Self::offset] based on the provided pagination settings
    ///
    /// The page number is 1-based.
    pub fn from_pagination_settings(page_number: u64, page_size: u64) -> Self {
        Self::new()
            .limit(page_size)
            .offset((page_number - 1) * page_size)
    }

    /// Returns a tuple `(page_number, page_size)` based on the provided
    /// [SelectionSettings::limit] and [SelectionSettings::offset] settings
    ///
    /// The page number is 1-based.
    ///
    /// Returns `None` if the limit or the offset is not set.
    pub fn get_pagination_settings(&self) -> Option<(u64, u64)> {
        self.limit
            .zip(self.offset)
            .map(|(limit, offset)| (1 + (offset as u64 / limit as u64), limit as u64))
    }
}

/// Describes how a [Model](super::Model) can be listed (and counted) in a database
/// given some settings and constraints provided by [SelectionSettings]
///
/// You can implement this type manually but it is recommended to use the `Model`
/// derive macro instead.
#[async_trait::async_trait]
pub trait List: Model {
    /// Lists the objects that match the provided settings
    async fn list(
        conn: &'async_trait mut DbConnection,
        settings: SelectionSettings<Self>,
    ) -> crate::error::Result<Vec<Self>>;
}

/// Describe how we can count the number of occurences of the [Model](super::Model)
/// that match the provided settings and constraints
///
/// You can implement this type manually but it is recommended to use the `Model`
/// derive macro instead.
#[async_trait::async_trait]
pub trait Count: Model {
    /// Counts the number of objects that match the provided settings
    async fn count(
        conn: &'async_trait mut DbConnection,
        settings: SelectionSettings<Self>,
    ) -> crate::error::Result<u64>;
}

/// A trait that combines [List] and [Count] into a single function [ListAndCount::list_and_count]
///
/// This trait is automatically implemented for any type that implements both [List] and [Count].
#[async_trait::async_trait]
pub trait ListAndCount: Model {
    /// Lists and counts the objects that match the provided settings
    ///
    /// # Performance
    ///
    /// This function has a default implementation that relies on [List::list] and [Count::count]
    /// It runs both queries **sequentially** (yet pipelined) so if performance issues arise,
    /// try in that order:
    ///
    /// 1. Run both queries **concurrently** instead if multiple connections can be obtained
    /// 2. Override this function with a more efficient implementation
    /// 3. Fetch in OSRD's git log that function original implementation and restore it
    ///    (this is a _very last resort_ solution ofc).
    async fn list_and_count(
        conn: &'async_trait mut DbConnection,
        settings: SelectionSettings<Self>,
    ) -> crate::error::Result<(Vec<Self>, u64)>;
}

#[async_trait::async_trait]
impl<M: Model + List + Count> ListAndCount for M {
    async fn list_and_count(
        conn: &'async_trait mut DbConnection,
        settings: SelectionSettings<Self>,
    ) -> crate::error::Result<(Vec<Self>, u64)> {
        let count = Self::count(conn, settings.clone()).await?;
        let list = Self::list(conn, settings).await?;
        Ok((list, count))
    }
}
