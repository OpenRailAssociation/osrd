use diesel::dsl::sql;
use diesel::expression::expression_types::NotSelectable;
use diesel::expression::{AsExpression, TypedExpressionType};
use diesel::pg::Pg;
use diesel::query_builder::{AstPass, Query, QueryFragment};
use diesel::sql_types::{BigInt, Bool, Nullable, SqlType};

use super::Model;

/// A dynamic container for a filter setting in a [SelectionSettings] context
///
/// This struct is not meant to be initialized direclty but rather through the
/// [ModelField](super::ModelField) objects generated by the `Model` derive macro expansion.
pub struct FilterSetting<M: Model>(pub(in crate::modelsv2) DieselFilter<M::Table>);
type DieselFilter<Table> = Box<dyn diesel::BoxableExpression<Table, Pg, SqlType = Bool>>;

impl<M: Model> FilterSetting<M> {
    /// Initializes a filter setting with a given filter expression
    ///
    /// This function is only used internally by the `Model` derive macro and it
    /// probably should stay that way. It exists to allow building a [FilterSetting]
    /// both from a `Bool` and `Nullable<Bool>` query by `COALESCE`ing the expression
    /// to `FALSE`. That way the `Model` derive macro doesn't have to infer the type
    /// of each field (as `column.eq(value)` is a `Nullable<Bool>` if `column` is a `Nullable<T>`).
    pub(in crate::modelsv2) fn new<T, Q>(filter: Q) -> Self
    where
        Q: AsExpression<T>,
        <Q as AsExpression<T>>::Expression: QueryFragment<Pg> + Send + 'static,
        T: SqlType + TypedExpressionType,
    {
        let expr = sql::<Bool>("COALESCE(").bind(filter).sql(", FALSE)");
        Self(Box::new(expr))
    }
}

/// A dynamic container for a sorting setting in a [SelectionSettings] context
///
/// This struct is not meant to be initialized direclty but rather through the
/// [ModelField](super::ModelField) objects generated by the `Model` derive macro expansion.
pub struct SortSetting<M: Model>(pub(in crate::modelsv2) DieselSort<M::Table>);
type DieselSort<Table> = Box<dyn diesel::BoxableExpression<Table, Pg, SqlType = NotSelectable>>;

/// A builder for model listing settings
///
/// See [List]
pub struct SelectionSettings<M: Model> {
    pub(in crate::modelsv2) filters: Vec<FilterSetting<M>>,
    pub(in crate::modelsv2) sorts: Vec<SortSetting<M>>,
    pub(in crate::modelsv2) limit: Option<i64>,
    pub(in crate::modelsv2) offset: Option<i64>,
}

impl<M: Model> Default for SelectionSettings<M> {
    fn default() -> Self {
        Self {
            filters: Vec::new(),
            sorts: Vec::new(),
            limit: None,
            offset: None,
        }
    }
}

impl<M: Model> SelectionSettings<M> {
    /// Initializes a settings builder with no constraints
    pub fn new() -> Self {
        Self::default()
    }

    /// Apply some filters
    pub fn filter(mut self, filter: FilterSetting<M>) -> Self {
        self.filters.push(filter);
        self
    }

    /// Apply some ordering criteria
    pub fn order_by(mut self, sort: SortSetting<M>) -> Self {
        self.sorts.push(sort);
        self
    }

    /// Limit the number of results
    pub fn limit(mut self, limit: u64) -> Self {
        self.limit = Some(limit.try_into().expect("limit is too large"));
        self
    }

    /// Offset the results by an amount
    pub fn offset(mut self, offset: u64) -> Self {
        self.offset = Some(offset.try_into().expect("offset is too large"));
        self
    }
}

/// Describes how a [Model](super::Model) can be listed (and counted) in a database
/// given some settings and constraints provided by [SelectionSettings]
///
/// You can implement this type manually but it is recommended to use the `Model`
/// derive macro instead.
#[async_trait::async_trait]
pub trait List: Model {
    /// Lists and counts the objects that match the provided settings
    async fn list_and_count(
        conn: &'async_trait mut diesel_async::AsyncPgConnection,
        settings: SelectionSettings<Self>,
    ) -> crate::error::Result<(Vec<Self>, u64)>;

    /// Lists the objects that match the provided settings
    ///
    /// This function has a default implementation that relies on [Self::list_and_count],
    /// but it is recommended to override it with a more efficient implementation if possible
    /// as the counting operation can be expensive.
    async fn list(
        conn: &'async_trait mut diesel_async::AsyncPgConnection,
        settings: SelectionSettings<Self>,
    ) -> crate::error::Result<Vec<Self>> {
        let (list, _) = Self::list_and_count(conn, settings).await?;
        Ok(list)
    }
}
